### 并发调度
>  因为Goroutine，Go才与众不同。  
>  Go的一切都在以并发形式运行，垃圾回收、系统监控、网络通信等等
### 基本图示
                               +----------------sysmon/监控线程--------------+
                               |                                            |
                               |                                            |
    go func() ----> G -------> P|local <----balance---> P|global <---//--- P|M
                   并发任务     本地队列                  全局队列            绑定
                               |                          |                 |
                               |                          |                 |
                               +----> M <--------findrunable----steal <--//-+
                                     系统线程     惯偷/从其他P的global部分加锁偷盗
                                      |
                                      |
                +--- execute <--- schedule
                |                  调度器
                |                    |
                +-> G.fn -> goexit --+
 ### 读Go Web编程一书有感 20190125
  1. 并行需要独立资源，而并发会使用和分享相同的资源
  2. goroutine并不是线程
  3. 因为groutine是轻量级的，数量可比线程数量多很多
  4. 一个goroutine启动时只需2KB左右大小的栈
  5. 简单函数不适用goroutine方式执行，因为goroutine多轻量级，都是需要消耗额外资源的
  6. goroutine适合用于多核系统，但增加CPU的数量并不一定会带来性能提升。因为在多个CPU上调度和运行任务需要消费一定资源，如果使用多个CPU带来的性能不足以抵消随之带来的额外消耗，酱紫性能不升反降
  7. 使用sync包的WaitGroup机制实现等待goroutine完成
  8. 使用通道实现goroutine间通讯
  9. goroutine用在web并发编程上，关键是把一个任务分割成几个独立的步骤，用goroutine使这些步骤并发执行，使用通道让这些并发步骤进行通信，从而实现协调工作
